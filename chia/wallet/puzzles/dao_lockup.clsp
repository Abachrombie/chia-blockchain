; This code is the "voting mode" for a DAO CAT.
; The coin can be spent from this state to vote on a proposal or claim a dividend.
; It locks the CAT in while it has active votes/dividends going on.
; Once a vote or dividend closes, then the coin can spend itself to remove that coin from the "active list"
; If the "active list" is empty the coin can leave the voting mode

(mod (
    PROPOSAL_MOD_HASH
    SINGLETON_MOD_HASH
    SINGLETON_LAUNCHER_PUZHASH
    LOCKUP_MOD_HASH
    CAT_MOD_HASH
    CAT_TAIL_HASH
    ACTIVE_VOTES  ; "active votes" list
    INNERPUZ
    my_id  ; if my_id is 0 we do the return to return_address (exit voting mode) spend case
    inner_solution
    my_amount
    new_proposal_vote_id_or_removal_id  ; if we're exiting fully, set this to 0
    proposal_curry_vals
    vote_info
    vote_amount
    my_inner_puzhash  ; [REVIEW - comments] I don't exactly have a better suggestion but I do know this name is confusing.  lockup_fullpuzhash or something maybe?
    new_innerpuzhash  ; only include this if we're changing owners - secured because coin is still made from inner_puz
  )
  (include condition_codes.clib)
  (include curry-and-treehash.clib)
  (include *standard-cl-21*)

  ; [REVIEW - misc] Why use a constant here rather than curry in?
  (defconstant dao_finished_state 0x7f3cc356732907933a8f9b1ccf16f71735d07340eb38c847aa402e97d75eb40b)

  (defun calculate_finished_state (singleton_struct dao_finished_state)
    (puzzle-hash-of-curried-function dao_finished_state  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      (sha256 ONE dao_finished_state)
      (sha256tree singleton_struct)
    )
  )

  ; take two lists and merge them into one
  (defun merge_list (list_a list_b)
    (if list_a
        (c (f list_a) (merge_list (r list_a) list_b))
        list_b
    )
  )

  (defun wrap_in_cat_layer (CAT_MOD_HASH CAT_TAIL_HASH INNERPUZHASH)
    (puzzle-hash-of-curried-function CAT_MOD_HASH  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      INNERPUZHASH
      (sha256 ONE CAT_TAIL_HASH)
      (sha256 ONE CAT_MOD_HASH)
    )
  )

  ; loop through conditions and check that they aren't trying to create anything they shouldn't
  (defun check_conditions (conditions vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change)
    (if conditions
        ; [REVIEW - architecture] I don't like restricting this CAT to one payment.  Couldn't you just forcibly wrap all of the outputs with the correct layer?
        (if (= (f (f conditions)) CREATE_COIN)  ; this guarantees that the new coin is obeying the rules - other coins are banned to avoid re-voting
            (if (= (f (r (f conditions))) vote_added_puzhash)
                (if seen_vote  ; assert we haven't already made a coin with the new vote included
                    (x)
                    ; [REVIEW - architecture] If you take my comment above about allowing multiple payments, you can dispense with this distinction and just vote with the whole value each time because people can divide their coins if they wish.
                    ; [^] I think like 99% of the time you just want to vote with your whole amount anyways.
                    (if (= (f (r (r (f conditions)))) my_amount)  ; we vote with all our value
                        (if seen_change  ; assert that we haven't already recreated ourself in some fashion
                            (x)
                            (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash 1 1))
                        )
                        (if (= (f (r (r (f conditions)))) vote_amount)  ; we vote with part of our power
                            (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash 1 seen_change))
                            (x)
                        )
                    )
                )
                ; [REVIEW - architecture] If you take my comment above about allowing multiple payments, you can dispense with this whole if branch
                (if (all
                      (= (f (r (f conditions))) my_inner_puzhash)
                      (not seen_change)
                      (= (f (r (r (f conditions)))) (- my_amount vote_amount))
                    )  ; we recreate ourselves with unused voting power
                    (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote 1))
                    (x)
                )
            )
            (if (= (f (f conditions)) CREATE_PUZZLE_ANNOUNCEMENT)  ; this secures the values used to generate message - other messages are banned in case of LIES  ; [REVIEW - comments] excellent use of capitalization
                (if (= (f (r (f conditions))) message)
                    (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change))
                    (x)
                )
                (c (f conditions) (check_conditions (r conditions) vote_added_puzhash my_amount message vote_amount my_inner_puzhash seen_vote seen_change))
            )
        )
        (if (all seen_vote seen_change)  ; check all value is accounted for
            ()
            (x)
        )
    )
  )

  ; go through our list of active votes and check that we aren't revoting
  (defun check_not_previously_voted (
      SINGLETON_MOD_HASH
      SINGLETON_LAUNCHER_PUZHASH
      LOCKUP_MOD_HASH
      CAT_MOD_HASH
      CAT_TAIL_HASH
      PROPOSAL_MOD_HASH
      INNERPUZ
      my_id
      new_vote_id
      active_votes
      proposal_curry_vals
    )
    (if active_votes
        (if (= new_vote_id (f active_votes))  ; check new vote id is not equal to an existing vote id
            (x)
            (check_not_previously_voted
              SINGLETON_MOD_HASH
              SINGLETON_LAUNCHER_PUZHASH
              LOCKUP_MOD_HASH
              CAT_MOD_HASH
              CAT_TAIL_HASH
              PROPOSAL_MOD_HASH
              INNERPUZ
              my_id
              new_vote_id
              (r active_votes)
              proposal_curry_vals
            )
        )
        ; [REVIEW - optimization] Do we actually care to secure on this end that in fact we are voting on a proposal?
        ; [^] Sure, you don't want someone to intercept your spend and only push this spend without the votes actually counting.
        ; [^] However, the inner puzzle could make this assertion to secure itself against MITM and it could calculate the proper proposal puzzle hash to assert off chain.
        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256  ; the problem might be here  ; [REVIEW - comments] ???
            (calculate_proposal_puzzlehash
              PROPOSAL_MOD_HASH
              CAT_MOD_HASH
              LOCKUP_MOD_HASH
              CAT_TAIL_HASH
              (c SINGLETON_MOD_HASH (c new_vote_id SINGLETON_LAUNCHER_PUZHASH))
              proposal_curry_vals
            )
            my_id
          )
        )
    )
  )


  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
    (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      inner_puzzle_hash
      (sha256tree PROPOSAL_SINGLETON_STRUCT)
    )
  )

  (defun calculate_proposal_puzzlehash (
      PROPOSAL_MOD_HASH
      CAT_MOD_HASH
      LOCKUP_MOD_HASH
      CAT_TAIL_HASH
      proposal_singleton_struct
      (
        TREASURY_MOD_HASH
        PROPOSAL_TIMER_MOD_HASH
        TREASURY_ID
        YES_VOTES
        TOTAL_VOTES
        INNERPUZHASH
      )
    )
    (calculate_singleton_puzzle_hash
      proposal_singleton_struct
      (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
        (sha256 ONE INNERPUZHASH)
        (sha256 ONE TOTAL_VOTES)
        (sha256 ONE YES_VOTES)
        (sha256 ONE TREASURY_ID)
        (sha256 ONE CAT_TAIL_HASH)
        (sha256 ONE LOCKUP_MOD_HASH)
        (sha256 ONE TREASURY_MOD_HASH)
        (sha256 ONE CAT_MOD_HASH)
        (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
        (sha256 ONE PROPOSAL_MOD_HASH)
        (sha256tree proposal_singleton_struct)
      )
    )
  )

  ; PROPOSAL_MOD_HASH
  ; SINGLETON_MOD_HASH
  ; SINGLETON_LAUNCHER_PUZHASH
  ; LOCKUP_MOD_HASH
  ; CAT_MOD_HASH
  ; CAT_TAIL_HASH
  ; ACTIVE_VOTES  ; "active votes" list
  ; INNERPUZ
  (defun calculate_lockup_puzzlehash (
      PROPOSAL_MOD_HASH
      SINGLETON_MOD_HASH
      SINGLETON_LAUNCHER_PUZHASH
      LOCKUP_MOD_HASH
      CAT_MOD_HASH
      CAT_TAIL_HASH
      active_votes
      innerpuzhash
    )
    ; [REVIEW - optimization] This is potentially pretty wasteful right?
    ; [^] There's a better way to do this which you can see for reference here https://github.com/Chia-Network/chia-blockchain/blob/49140b2b3c0c128f2464c0b4e50c496e7029939d/chia/wallet/vc_wallet/cr_puzzles/credential_restriction.clsp#L30-L35
    ; [^] Basically, you curry the program twice:
    ; [^] - First, with everything except LOCKUP_MOD_HASH, ACTIVE_VOTES, and INNERPUZ that's already curried in above
    ; [^] - Second, you hash the program you have just created and curry that hash into the program as well as SELF_HASH
    ; [^] (Note that doing this means there's no need for LOCKUP_MOD_HASH as it's implicit in the first hash)
    ; [^] Then this call can be much less expensive in execution: (puzzle-hash-of-curried-function SELF_HASH innerpuzhash active_votes (sha256 ONE SELF_HASH))
    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      innerpuzhash
      (sha256tree active_votes)
      (sha256 ONE CAT_TAIL_HASH)
      (sha256 ONE CAT_MOD_HASH)
      (sha256 ONE LOCKUP_MOD_HASH)
      (sha256 ONE SINGLETON_LAUNCHER_PUZHASH)
      (sha256 ONE SINGLETON_MOD_HASH)
      (sha256 ONE PROPOSAL_MOD_HASH)
    )
  )

  ; search for an announcement that a proposal is finished and then remove that proposal ID from ACTIVE_VOTES
  (defun check_for_removal_announcement (
      PROPOSAL_MOD_HASH
      SINGLETON_MOD_HASH
      SINGLETON_LAUNCHER_PUZHASH
      LOCKUP_MOD_HASH
      CAT_MOD_HASH
      CAT_TAIL_HASH
      ACTIVE_VOTES
      INNERPUZ
      removal_id
      my_amount
      proposal_curry_vals
      unused_votes
    )
    ; [REVIEW - architecture] I'm not a huge fan that this does not run the inner puzzle.
    ; [^] These CATs still belong to the user and maybe they want to do some weird announcement while removing a voting thing, I'm not sure.
    ; [^] The point is, I think moving to a validation pattern here would make sense and potentially could be more optimal (can still prepend the assert)
    ; [REVIEW - architecture] I think there's probably a way to do this where you could remove multiple ongoing votes at once.  This would save some user fees.
    (if ACTIVE_VOTES
        (if (= (f ACTIVE_VOTES) removal_id)
            (list
              (list
                CREATE_COIN  ; recreate self with the finished proposal ID removed
                (calculate_lockup_puzzlehash
                  PROPOSAL_MOD_HASH
                  SINGLETON_MOD_HASH
                  SINGLETON_LAUNCHER_PUZHASH
                  LOCKUP_MOD_HASH
                  CAT_MOD_HASH
                  CAT_TAIL_HASH
                  ; [REVIEW - misc] merge_list merges from the left I believe which means this will shuffle the vote order and that seems less than ideal
                  (merge_list unused_votes (r ACTIVE_VOTES))  ; removes the current entry from the list
                  (sha256tree INNERPUZ)
                )
                my_amount
              )
              (list
                ASSERT_PUZZLE_ANNOUNCEMENT  ; check proposal is actually finished
                (sha256
                  (calculate_singleton_puzzle_hash
                    ; [REVIEW - optimization] Do this a layer above (calculate_lockup_puzzlehash will need to unpack it but it's just a path reference, very cheap)
                    (c SINGLETON_MOD_HASH (c removal_id SINGLETON_LAUNCHER_PUZHASH))
                    (calculate_finished_state
                      (c SINGLETON_MOD_HASH (c removal_id SINGLETON_LAUNCHER_PUZHASH))
                      dao_finished_state
                    )
                  )
                  'f'
                )
              )
              (list ASSERT_MY_AMOUNT my_amount)  ; assert that we aren't lying about our amount to free up money and re-vote
            )
            ; [REVIEW - comments] the comment on the next line should go here I think (don't really care, just a thought)
            (check_for_removal_announcement  ; keep looping through ACTIVE_VOTES to search for removal_id
              PROPOSAL_MOD_HASH
              SINGLETON_MOD_HASH
              SINGLETON_LAUNCHER_PUZHASH
              LOCKUP_MOD_HASH
              CAT_MOD_HASH
              CAT_TAIL_HASH
              (r ACTIVE_VOTES)
              INNERPUZ
              removal_id
              my_amount
              proposal_curry_vals
              (c (f ACTIVE_VOTES) unused_votes)
            )
        )
        (x)  ; proposal ID not found, invalid spend
    )
  )


  ; main
  (if my_id
      (c (list ASSERT_MY_PUZZLEHASH (wrap_in_cat_layer CAT_MOD_HASH CAT_TAIL_HASH my_inner_puzhash))
        (c
          (list ASSERT_MY_AMOUNT my_amount)
          (c
            (list ASSERT_MY_COIN_ID my_id)
            (c
              (if new_proposal_vote_id_or_removal_id
                  (check_not_previously_voted  ; this returns a single condition asserting announcement from vote singleton
                    SINGLETON_MOD_HASH
                    SINGLETON_LAUNCHER_PUZHASH
                    LOCKUP_MOD_HASH
                    CAT_MOD_HASH
                    CAT_TAIL_HASH
                    PROPOSAL_MOD_HASH
                    INNERPUZ
                    my_id
                    new_proposal_vote_id_or_removal_id
                    ACTIVE_VOTES
                    proposal_curry_vals
                  )
                  (list REMARK)
              )

              (check_conditions  ; loop over conditions and check that we aren't trying to leave voting state
                (a INNERPUZ inner_solution)
                (calculate_lockup_puzzlehash  ; compare created coin to our own calculation on what the next puzzle should be
                  PROPOSAL_MOD_HASH
                  SINGLETON_MOD_HASH
                  SINGLETON_LAUNCHER_PUZHASH
                  LOCKUP_MOD_HASH
                  CAT_MOD_HASH
                  CAT_TAIL_HASH
                  ; [REVIEW - misc] If my reading of the code above is correct, this will result in some ()'s in this list which seems not great
                  (c new_proposal_vote_id_or_removal_id ACTIVE_VOTES)
                  ; [REVIEW - optimization] I think just always passing this in is almost always going to be cheaper than hashing the existing innerpuz
                  (if new_innerpuzhash new_innerpuzhash (sha256tree INNERPUZ))
                )
                my_amount
                ; [REVIEW - comments] Make sure you do this TODO, I think it's pretty important
                ; TODO: add namespace to this announcement to allow announcements from the innerpuz
                (sha256tree (list new_proposal_vote_id_or_removal_id vote_amount vote_info my_id))  ; (sha256tree (list (f (r SINGLETON_STRUCT)) (f vote_amount_list) vote_info (f coin_id_list)))
                vote_amount
                my_inner_puzhash
                0
                0
              )
            )
          )
        )
      )

      ; return to return_address or remove something from active list - check if our locked list is empty
      (if ACTIVE_VOTES
          ; [REVIEW - comments] the comment on the next line should go here I think (don't really care, just a thought)
          (check_for_removal_announcement  ; locked list is not empty, so we must be trying to remove something from it
            PROPOSAL_MOD_HASH
            SINGLETON_MOD_HASH
            SINGLETON_LAUNCHER_PUZHASH
            LOCKUP_MOD_HASH
            CAT_MOD_HASH
            CAT_TAIL_HASH
            ACTIVE_VOTES
            INNERPUZ
            new_proposal_vote_id_or_removal_id
            my_amount
            proposal_curry_vals
            ()
          )
          (a INNERPUZ inner_solution)
      )
  )
)
