(mod
  (
    TREASURY_MOD_HASH
    PROPOSAL_VALIDATOR
    PROPOSAL_LENGTH
    PROPOSAL_SOFTCLOSE_LENGTH
    ATTENDANCE_REQUIRED
    PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
    PROPOSAL_SELF_DESTRUCT_TIME ; time in seconds after which proposals can be automatically closed
    ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
    proposal_or_oracle_flag ; if 'p' then run the proposal, if 'o' then run the oracle path
    (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
    proposal_validator_solution
    delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
    delegated_solution  ; this is not secure unless the delegated puzzle secures it
  )
  (include utility_macros.clib)
  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  (defun merge_list (list_a list_b)
    (if list_a
      (c (f list_a) (merge_list (r list_a) list_b))
      list_b
    )
  )

  (defun recreate_self (
    TREASURY_MOD_HASH
    PROPOSAL_VALIDATOR
    PROPOSAL_LENGTH
    PROPOSAL_SOFTCLOSE_LENGTH
    ATTENDANCE_REQUIRED
    PASS_MARGIN
    PROPOSAL_SELF_DESTRUCT_TIME
    ORACLE_SPEND_DELAY
  )
    (list CREATE_COIN
      (puzzle-hash-of-curried-function TREASURY_MOD_HASH
          (sha256 ONE ORACLE_SPEND_DELAY)
          (sha256 ONE PROPOSAL_SELF_DESTRUCT_TIME)
          (sha256 ONE PASS_MARGIN)
          (sha256 ONE ATTENDANCE_REQUIRED)
          (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
          (sha256 ONE PROPOSAL_LENGTH)
          (sha256tree PROPOSAL_VALIDATOR)
	        (sha256 ONE TREASURY_MOD_HASH)
      )
      ONE ; we're assuming treasury will always have 1 mojo in amount
    )
  )

  (if (= proposal_or_oracle_flag 'p')
    ; if we're checking a proposal
    (assert (= (sha256tree delegated_puzzle_reveal) delegated_puzzle_hash)
      ; Merge the treasury conditions with the proposal validator conditions
      ; If the update case then the validator returns the new treasury create coin
      ; If the spend case then we need to recreate the treasury outselves
      (merge_list
	; treasury specific conditions
	(c
	  (list CREATE_PUZZLE_ANNOUNCEMENT
	    (sha256tree
	      (list
		(f proposal_validator_solution)
		PROPOSAL_LENGTH
		PROPOSAL_SOFTCLOSE_LENGTH
		ATTENDANCE_REQUIRED
		PASS_MARGIN
	      )
	    )
	  )
	  (c
	    ; also announce the oracle info so proposals can close if treasury is being spammed
	    ; TODO: could we include these values in the announcement above so there is only one CPA
	    (list CREATE_PUZZLE_ANNOUNCEMENT (sha256 PASS_MARGIN PROPOSAL_SELF_DESTRUCT_TIME))
	    (c
	      (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 announcement_source (sha256tree (list spend_or_update_flag delegated_puzzle_hash announcement_args))))
	      (if (= spend_or_update_flag "s")
		; spend case, recreate the treasury
		(c
		  (recreate_self TREASURY_MOD_HASH PROPOSAL_VALIDATOR PROPOSAL_LENGTH PROPOSAL_SOFTCLOSE_LENGTH ATTENDANCE_REQUIRED PASS_MARGIN PROPOSAL_SELF_DESTRUCT_TIME)
		  ()
		)
		; update case, so don't recreate the treasury
		()
	      )
	    )
	  )
	)
	; conditions output by the proposal
	(a
	  PROPOSAL_VALIDATOR
	  (list
	    ATTENDANCE_REQUIRED
	    PASS_MARGIN
	    proposal_announcement
	    proposal_validator_solution
	    (a delegated_puzzle_reveal delegated_solution)
	  )
	)
      )
    )

    (if (= proposal_or_oracle_flag 'o')
      ; create the oracle announcement
      (list
        (list CREATE_PUZZLE_ANNOUNCEMENT (sha256 PASS_MARGIN PROPOSAL_SELF_DESTRUCT_TIME))
      	(list ASSERT_HEIGHT_RELATIVE ORACLE_SPEND_DELAY)
      	(recreate_self
          TREASURY_MOD_HASH
          PROPOSAL_VALIDATOR
          PROPOSAL_LENGTH
          PROPOSAL_SOFTCLOSE_LENGTH
          ATTENDANCE_REQUIRED
          PASS_MARGIN
          PROPOSAL_SELF_DESTRUCT_TIME
          ORACLE_SPEND_DELAY
        )
      )
      (x) ; invalid proposal_or_oracle_flag
    )
  )
)
