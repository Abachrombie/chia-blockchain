; This is a proposal which lives inside a singleton, it represents a proposed way to spend DAO money
; If the proposal passes the vote, the INNERPUZ inside it will run, and the DAO Treasury will accept a spend to change itself or spend money
;
; ACTIONS:
; add_votes(vote_amount, vote_info, vote_coin_id, previous_votes, lockup_innerpuzhash) -> Add new votes to to previous_votes by spending CAT with lockup_innerpuzhash and recreate_self
;    vote_amount:         vote_amount_or_solution
;    vote_info:           vote_info_or_p2_singleton_mod_hash
;    vote_coin_id:        vote_coin_id_or_current_cat_issuance
;    lockup_innerpuzhash: lockup_innerpuzhash_or_attendance_required
;
; terminate_this_proposal(solution, current_cat_issuance) -> (run_chialisp OR dont_run_chialisp) AND kill proposal by recreate("u", previous_votes=0)
;    solution:             vote_amount_or_solution
;    current_cat_issuance: vote_coin_id_or_current_cat_issuance


(mod (
  SINGLETON_STRUCT  ; (SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH))
  PROPOSAL_MOD_HASH
  PROPOSAL_TIMER_MOD_HASH ; proposal timer needs to know which proposal created it, AND
  CAT_MOD_HASH
  TREASURY_MOD_HASH
  LOCKUP_MOD_HASH
  CAT_TAIL_HASH
  TREASURY_ID
  YES_VOTES  ; yes votes are +1, no votes don't tally - we compare yes_votes/total_votes at the end
  TOTAL_VOTES  ; how many people responded
  INNERPUZ  ; this is what runs if this proposal is successful - the inner puzzle of this proposal. Rename as PROPOSAL_PUZZLE ?
  vote_amount_or_solution  ; The qty of "votes" to add or subtract. ALWAYS POSITIVE.
  vote_info_or_p2_singleton_mod_hash ; vote_info is whether we are voting YES or NO. XXX rename vote_type?
  vote_coin_id_or_current_cat_issuance  ; this is either the coin ID we're taking a vote from OR...
                                        ; the total number of CATs in circulation according to the treasury
  previous_votes_or_pass_margin  ; this is the active votes of the lockup we're communicating with
                                 ; OR this is what percentage of the total votes must be YES - represented as an integer from 0 to 10,000 - typically this is set at 5100 (51%)
  lockup_innerpuzhash_or_attendance_required  ; this is either the innerpuz of the locked up CAT we're taking a vote from OR
                                              ; the attendance required - the percentage of the current issuance which must have voted represented as 0 to 10,000 - this is announced by the treasury
  proposal_timelock  ; we assert this from the treasury and announce it, so the timer knows what the the current timelock is
                     ; we only use this when closing out so set it to 0 and we will do the vote spend case

)
  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)
  (include *standard-cl-21*)

  (defconstant TEN_THOUSAND 10000)
  (defconstant dao_finished_state 0xfb015415f2e6a09c1141f880fc2135beec6adf2a19e4d02a191432846db16559)

  (defun-inline calculate_win_percentage (CURRENT_CAT_ISSUANCE PROPOSAL_PASS_PERCENTAGE)
    (f (divmod (* CURRENT_CAT_ISSUANCE PROPOSAL_PASS_PERCENTAGE) TEN_THOUSAND))
  )

  (defun calculate_timer_puzhash (
    PROPOSAL_TIMER_MOD_HASH
    PROPOSAL_MOD_HASH
    CAT_TAIL_HASH
    MY_SINGLETON_STRUCT
    TREASURY_ID
  )
    (puzzle-hash-of-curried-function PROPOSAL_TIMER_MOD_HASH
                                     (sha256 ONE TREASURY_ID)
                                     (sha256tree MY_SINGLETON_STRUCT)
                                     (sha256 ONE CAT_TAIL_HASH)
                                     (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
                                     (sha256 ONE PROPOSAL_MOD_HASH)
    )
  )

  (defun calculate_lockup_puzzlehash (
    PROPOSAL_MOD_HASH
    SINGLETON_MOD_HASH
    SINGLETON_LAUNCHER_PUZHASH
    LOCKUP_MOD_HASH
    CAT_MOD_HASH
    CAT_TAIL_HASH
    previous_votes
    lockup_innerpuzhash
  )
    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH
                                     lockup_innerpuzhash
                                     (sha256tree previous_votes)
                                     (sha256 ONE CAT_TAIL_HASH)
                                     (sha256 ONE CAT_MOD_HASH)
                                     (sha256 ONE LOCKUP_MOD_HASH)
                                     (sha256 ONE SINGLETON_LAUNCHER_PUZHASH)
                                     (sha256 ONE SINGLETON_MOD_HASH)
                                     (sha256 ONE PROPOSAL_MOD_HASH)
    )
  )

  (defun recreate_self (
    SINGLETON_STRUCT
    PROPOSAL_MOD_HASH
    PROPOSAL_TIMER_MOD_HASH
    CAT_MOD_HASH
    LOCKUP_MOD_HASH
    TREASURY_MOD_HASH
    CAT_TAIL_HASH
    TREASURY_ID
    YES_VOTES
    TOTAL_VOTES
    INNERPUZ
  )
    (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
                                     (sha256tree INNERPUZ)
                                     (sha256 ONE TOTAL_VOTES)
                                     (sha256 ONE YES_VOTES)
                                     (sha256 ONE TREASURY_ID)
                                     (sha256 ONE CAT_TAIL_HASH)
				                             (sha256 ONE TREASURY_MOD_HASH)
                                     (sha256 ONE LOCKUP_MOD_HASH)
                                     (sha256 ONE CAT_MOD_HASH)
                                     (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
                                     (sha256 ONE PROPOSAL_MOD_HASH)
                                     (sha256tree SINGLETON_STRUCT)
    )
  )

  (defun wrap_in_cat_layer (CAT_MOD_HASH CAT_TAIL_HASH INNERPUZHASH)
    (puzzle-hash-of-curried-function CAT_MOD_HASH
                                     INNERPUZHASH
                                     (sha256 ONE CAT_TAIL_HASH)
                                     (sha256 ONE CAT_MOD_HASH)
    )
  )

  (defun calculate_singleton_puzzle_hash (PROPOSAL_SINGLETON_STRUCT inner_puzzle_hash)
     (puzzle-hash-of-curried-function (f PROPOSAL_SINGLETON_STRUCT)
                                      inner_puzzle_hash
                                      (sha256tree PROPOSAL_SINGLETON_STRUCT)
     )
  )

  (defun calculate_treasury_puzzlehash (
    TREASURY_MOD_HASH
    treasury_singleton_struct
    PROPOSAL_MOD_HASH
    PROPOSAL_TIMER_MOD_HASH
    LOCKUP_MOD_HASH
    CAT_MOD_HASH
    CAT_TAIL_HASH
    CURRENT_CAT_ISSUANCE
    ATTENDANCE_REQUIRED_PERCENTAGE
    PROPOSAL_PASS_PERCENTAGE
    PROPOSAL_TIMELOCK
    )
    (calculate_singleton_puzzle_hash treasury_singleton_struct
      (puzzle-hash-of-curried-function TREASURY_MOD_HASH
        (sha256tree (list
          treasury_singleton_struct
          TREASURY_MOD_HASH
          PROPOSAL_MOD_HASH
          PROPOSAL_TIMER_MOD_HASH
          LOCKUP_MOD_HASH
          CAT_MOD_HASH
          CAT_TAIL_HASH
          CURRENT_CAT_ISSUANCE
          ATTENDANCE_REQUIRED_PERCENTAGE
          PROPOSAL_PASS_PERCENTAGE
          PROPOSAL_TIMELOCK
        ))
      )
    )
  )

  (defun loop_over_vote_coins (
    SINGLETON_STRUCT
    CAT_MOD_HASH
    CAT_TAIL_HASH
    LOCKUP_MOD_HASH
    PROPOSAL_MOD_HASH
    PROPOSAL_TIMER_MOD_HASH
    TREASURY_MOD_HASH
    LOCKUP_MOD_HASH
    TREASURY_ID
    YES_VOTES
    TOTAL_VOTES
    INNERPUZ
    coin_id_list
    vote_amount_list
    previous_votes
    lockup_innerpuzhashes
    vote_info
    sum
    output
  )
    (if coin_id_list
      (c
        (list CREATE_PUZZLE_ANNOUNCEMENT (f coin_id_list))
        (c
          (list
            ASSERT_PUZZLE_ANNOUNCEMENT  ; take the vote
            (sha256
              (wrap_in_cat_layer
                CAT_MOD_HASH
                CAT_TAIL_HASH
                (calculate_lockup_puzzlehash  ; because the message comes from
                  PROPOSAL_MOD_HASH
                  (f SINGLETON_STRUCT)
                  (r (r SINGLETON_STRUCT))
                  LOCKUP_MOD_HASH
                  CAT_MOD_HASH
                  CAT_TAIL_HASH
                  (f previous_votes)
                  (f lockup_innerpuzhashes)
                )
              )
              (sha256tree (list (f (r SINGLETON_STRUCT)) (f vote_amount_list) vote_info (f coin_id_list)))
            )
          )
          (loop_over_vote_coins
            SINGLETON_STRUCT
            CAT_MOD_HASH
            CAT_TAIL_HASH
            LOCKUP_MOD_HASH
            PROPOSAL_MOD_HASH
            PROPOSAL_TIMER_MOD_HASH
            TREASURY_MOD_HASH
            LOCKUP_MOD_HASH
            TREASURY_ID
            YES_VOTES
            TOTAL_VOTES
            INNERPUZ
            (r coin_id_list)
            (r vote_amount_list)
            (r previous_votes)
            (r lockup_innerpuzhashes)
            vote_info
            (+ (f vote_amount_list) sum)
            output
          )
        )
      )
      (c
        (list
          CREATE_COIN  ; recreate self with vote information added
          (recreate_self
            SINGLETON_STRUCT
            PROPOSAL_MOD_HASH
            PROPOSAL_TIMER_MOD_HASH
            CAT_MOD_HASH
            LOCKUP_MOD_HASH
            TREASURY_MOD_HASH
            CAT_TAIL_HASH
            TREASURY_ID
            (if vote_info (+ YES_VOTES sum) YES_VOTES)
            (+ TOTAL_VOTES sum)
            INNERPUZ
          )
          ONE  ; why would a proposal hold any value
          (c TREASURY_ID 0)  ; hint to Treasury ID so people can find it
        )
        output
      )
    )

  )


  ; main

  (if proposal_timelock
    ; terminate_this_proposal: End the proposal, and run (INNERPUZ solution) if the proposal passed
    (c
      (list CREATE_COIN dao_finished_state ONE (c (f (r SINGLETON_STRUCT)) 0))  ; move to announce finished mode. See previous comment about proposal amounts
      (c
        (list ASSERT_HEIGHT_RELATIVE 5)  ; soft close so all votes can get in
        (c
          (list ASSERT_PUZZLE_ANNOUNCEMENT  ; make sure that we actually have a matching treasury spend
            (sha256
              (calculate_treasury_puzzlehash
                TREASURY_MOD_HASH
                (c (f SINGLETON_STRUCT) (c TREASURY_ID (r (r SINGLETON_STRUCT))))
                PROPOSAL_MOD_HASH
                PROPOSAL_TIMER_MOD_HASH
                LOCKUP_MOD_HASH
                CAT_MOD_HASH
                CAT_TAIL_HASH
                vote_coin_id_or_current_cat_issuance
                lockup_innerpuzhash_or_attendance_required  ; check the veracity of these values by if the treasury uses them
                previous_votes_or_pass_margin  ; check the veracity of these values by if the treasury uses them
                proposal_timelock  ; check the veracity of these values by if the treasury uses them
              )
              (f (r SINGLETON_STRUCT))
            )
          )
          (c
            (list
              CREATE_PUZZLE_ANNOUNCEMENT
              (sha256tree
                (list
                  TREASURY_ID
                  proposal_timelock  ; this is included so that the timer can assert and verify
                )
              )
            )  ; create an announcement so the treasury can sync with us
            (c
              (list
                ASSERT_PUZZLE_ANNOUNCEMENT (sha256  ; external timer
                (calculate_timer_puzhash
                  PROPOSAL_TIMER_MOD_HASH
                  PROPOSAL_MOD_HASH
                  CAT_TAIL_HASH
                  SINGLETON_STRUCT
                  TREASURY_ID
                )
                (f (r SINGLETON_STRUCT))
                )
              )
              (if
                (all
                  (> TOTAL_VOTES (calculate_win_percentage vote_coin_id_or_current_cat_issuance lockup_innerpuzhash_or_attendance_required))
                  (> YES_VOTES (calculate_win_percentage TOTAL_VOTES previous_votes_or_pass_margin))
                )
                (a INNERPUZ vote_amount_or_solution)  ; run_chialisp: run proposed chialisp ; XXX Matt, Geoff: should we also re-create ourself with previous_votes=0 in this case?
                (list (list CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list "u" 0))))  ; dont_run_chialisp: we dont run the chialisp, but we still move to the finished state
                                                                                    ;    and let the treasury know to remain the same
              )
            )
          )
        )
      )
    )
    ; We are adding votes to this proposal. vote_info indicates a YES or NO vote.
    (loop_over_vote_coins
      SINGLETON_STRUCT
      CAT_MOD_HASH
      CAT_TAIL_HASH
      LOCKUP_MOD_HASH
      PROPOSAL_MOD_HASH
      PROPOSAL_TIMER_MOD_HASH
      TREASURY_MOD_HASH
      LOCKUP_MOD_HASH
      TREASURY_ID
      YES_VOTES
      TOTAL_VOTES
      INNERPUZ
      vote_coin_id_or_current_cat_issuance
      vote_amount_or_solution
      previous_votes_or_pass_margin
      lockup_innerpuzhash_or_attendance_required
      vote_info_or_p2_singleton_mod_hash
      0
      (if (any YES_VOTES TOTAL_VOTES)  ; this prevents the timer from being created if the coin has been created with fake votes
        ()
        (list
          (list
            CREATE_COIN
            (calculate_timer_puzhash
              PROPOSAL_TIMER_MOD_HASH
              PROPOSAL_MOD_HASH
              CAT_TAIL_HASH
              SINGLETON_STRUCT
              TREASURY_ID
            )
            0
          )
        )
      )
    )
  )
)
