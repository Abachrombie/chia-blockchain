(mod
  (
    TREASURY_MOD_HASH
    PROPOSAL_VALIDATOR  ; this is the curryed proposal validator
    PROPOSAL_LENGTH
    PROPOSAL_SOFTCLOSE_LENGTH
    ATTENDANCE_REQUIRED
    PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
    PROPOSAL_SELF_DESTRUCT_TIME  ; time in seconds after which proposals can be automatically closed
    ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
    proposal_flag  ; if this is set then we are closing a proposal
    (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
    proposal_validator_solution
    delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
    delegated_solution  ; this is not secure unless the delegated puzzle secures it
  )
  (include utility_macros.clib)
  (include condition_codes.clib)
  (include curry-and-treehash.clib)

  (defun-inline recreate_self (
      TREASURY_MOD_HASH
      PROPOSAL_VALIDATOR
      PROPOSAL_LENGTH
      PROPOSAL_SOFTCLOSE_LENGTH
      ATTENDANCE_REQUIRED
      PASS_MARGIN
      PROPOSAL_SELF_DESTRUCT_TIME
      ORACLE_SPEND_DELAY
    )
    (list CREATE_COIN
      (puzzle-hash-of-curried-function TREASURY_MOD_HASH
        (sha256 ONE ORACLE_SPEND_DELAY)
        (sha256 ONE PROPOSAL_SELF_DESTRUCT_TIME)
        (sha256 ONE PASS_MARGIN)
        (sha256 ONE ATTENDANCE_REQUIRED)
        (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
        (sha256 ONE PROPOSAL_LENGTH)
        (sha256tree PROPOSAL_VALIDATOR)
        (sha256 ONE TREASURY_MOD_HASH)
      )
      ONE  ; we're assuming treasury will always have 1 mojo in amount
    )
  )

  (if proposal_flag
      ; if we're checking a proposal (testing if it has passed)
      (if (= (sha256tree delegated_puzzle_reveal) delegated_puzzle_hash)
          ; Merge the treasury conditions with the proposal validator conditions
          ; If the update case then the validator returns the new treasury create coin
          ; If the spend case then we need to recreate the treasury outselves
          ; treasury specific conditions
          (c
            (list CREATE_PUZZLE_ANNOUNCEMENT (f proposal_validator_solution))  ; specify the proposal we're talking about
            (c
              ; also announce the oracle info so proposals can close if treasury is being spammed
              (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
              (c
                (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 announcement_source (sha256tree (list delegated_puzzle_hash announcement_args))))  ; announcement source is validated inside the ProposalValidator
                (a
                  PROPOSAL_VALIDATOR
                  (list
                    ATTENDANCE_REQUIRED
                    PASS_MARGIN
                    proposal_announcement
                    proposal_validator_solution
                    (a delegated_puzzle_reveal delegated_solution)
                  )
                )
              )
            )
          )
          (x)
      )
      ; no proposal_flag so create the oracle announcement
      (list
        ; add announcement attendance required
        (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
        (if proposal_validator_solution (list ASSERT_EPHEMERAL) (list ASSERT_HEIGHT_RELATIVE ORACLE_SPEND_DELAY))
        (recreate_self
          TREASURY_MOD_HASH
          PROPOSAL_VALIDATOR
          PROPOSAL_LENGTH
          PROPOSAL_SOFTCLOSE_LENGTH
          ATTENDANCE_REQUIRED
          PASS_MARGIN
          PROPOSAL_SELF_DESTRUCT_TIME
          ORACLE_SPEND_DELAY
        )
      )
  )
)
