(mod
  (
    TREASURY_MOD_HASH
    PROPOSAL_VALIDATOR  ; this is the curryed proposal validator
    PROPOSAL_LENGTH  ; [REVIEW - comments] comment here would be good
    PROPOSAL_SOFTCLOSE_LENGTH  ; [REVIEW - comments] comment here would be good
    ATTENDANCE_REQUIRED  ; [REVIEW - comments] comment here would be good
    PASS_MARGIN  ; this is a percentage 0 - 10,000 - 51% would be 5100
    PROPOSAL_SELF_DESTRUCT_TIME  ; time in seconds after which proposals can be automatically closed
    ORACLE_SPEND_DELAY  ; timelock delay for oracle spend
    proposal_flag  ; if this is set then we are closing a proposal
    ; [REVIEW - bugs] I think in CI this will fail since you're not specifying (include *standard-cl-21*) or whatever.
    ; [REVIEW - optimization] It might be worth testing this program without the destructuring and using classic compiler.  The newer compiler versions aren't as good at optimization quite yet.
    (@ proposal_announcement (announcement_source delegated_puzzle_hash announcement_args spend_or_update_flag))
    proposal_validator_solution
    delegated_puzzle_reveal  ; this is the reveal of the puzzle announced by the proposal
    delegated_solution  ; this is not secure unless the delegated puzzle secures it
    my_singleton_struct  ; [REVIEW - comments] comment here would be good
  )
  (include utility_macros.clib)
  (include condition_codes.clib)
  (include curry-and-treehash.clib)

  (defun-inline recreate_self (
      TREASURY_MOD_HASH
      PROPOSAL_VALIDATOR
      PROPOSAL_LENGTH
      PROPOSAL_SOFTCLOSE_LENGTH
      ATTENDANCE_REQUIRED
      PASS_MARGIN
      PROPOSAL_SELF_DESTRUCT_TIME
      ORACLE_SPEND_DELAY
    )
    ; [REVIEW - optimization] This is potentially _very_ wasteful right?  All of these are constants meaning that this is whole call is actually itself a constant
    ; [^] There's a better way to do this which you can see for reference here https://github.com/Chia-Network/chia-blockchain/blob/49140b2b3c0c128f2464c0b4e50c496e7029939d/chia/wallet/vc_wallet/cr_puzzles/credential_restriction.clsp#L30-L35
    ; [^] Basically, you curry the program twice:
    ; [^] - First, with PROPOSAL_VALIDATOR thru ORACLE_SPEND_DELAY above
    ; [^] - Second, you hash the program you have just created and curry that hash into the program as well as SELF_HASH
    ; [^] (Note that doing this means there's no need for TREASURY_MOD_HASH as it's implicit in the first hash)
    ; [^] Then this call can be much less expensive in execution: (puzzle-hash-of-curried-function SELF_HASH (sha256 ONE SELF_HASH))
    (puzzle-hash-of-curried-function TREASURY_MOD_HASH  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      (sha256 ONE ORACLE_SPEND_DELAY)
      (sha256 ONE PROPOSAL_SELF_DESTRUCT_TIME)
      (sha256 ONE PASS_MARGIN)
      (sha256 ONE ATTENDANCE_REQUIRED)
      (sha256 ONE PROPOSAL_SOFTCLOSE_LENGTH)
      (sha256 ONE PROPOSAL_LENGTH)
      (sha256tree PROPOSAL_VALIDATOR)
      (sha256 ONE TREASURY_MOD_HASH)
    )
  )

  (defun calculate_singleton_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)  ; [REVIEW - misc]  I think curry_hashes or curry_hashes_inline here will be less expensive/have a more sensible API.  I think we're trying to deprecate this function.
      inner_puzzle_hash
      (sha256tree SINGLETON_STRUCT)
    )
  )

  ; [REVIEW - comment] I'm not sure why this is a thing.  A comment here would be good.
  ; [REVIEW - optimization] I could be confused (see comment above) but this seems to be a hack in place for the sake of wallet complexity when spending the thing for the first time after launch
  ; [^] I'm not convinced this is a good idea, the wallet could just handle the eve spend dynamically no?  This puzzle doesn't care whether or not it's the first or 500th spend of the singleton.
  (defun stager (ORACLE_SPEND_DELAY my_inner_puzhash singleton_struct)
    (c
      (if singleton_struct
          (list ASSERT_MY_COIN_ID
            (sha256
              (f (r singleton_struct))
              (calculate_singleton_puzzle_hash singleton_struct my_inner_puzhash)
              ONE
            )
          )
          (list ASSERT_HEIGHT_RELATIVE ORACLE_SPEND_DELAY)
      )
      (list (list CREATE_COIN my_inner_puzhash ONE))
    )
  )

  (if proposal_flag
      ; if we're checking a proposal (testing if it has passed)
      (if (= (sha256tree delegated_puzzle_reveal) delegated_puzzle_hash)  ; [REVIEW - optimization] can we just switch here on whether or not the dpuz is () instead of requiring a whole extra proposal_flag variable?
          ; Merge the treasury conditions with the proposal validator conditions
          ; If the update case then the validator returns the new treasury create coin
          ; If the spend case then we need to recreate the treasury outselves
          ; treasury specific conditions
          (c
            ; [REVIEW - architecture] not a fan of this assumption that the solution is a certain format.  I think either this announcement should go inside the validator or the proposal ID should be specified at this layer and passed as a truth to the layer below.
            (list CREATE_PUZZLE_ANNOUNCEMENT (f proposal_validator_solution))  ; specify the proposal we're talking about
            (c
              ; also announce the oracle info so proposals can close if treasury is being spammed
              (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
              (c
                (list ASSERT_COIN_ANNOUNCEMENT (sha256 announcement_source (sha256tree (list delegated_puzzle_hash announcement_args))))  ; announcement source is validated inside the ProposalValidator
                (a
                  PROPOSAL_VALIDATOR
                  (list
                    ATTENDANCE_REQUIRED
                    PASS_MARGIN
                    proposal_announcement
                    proposal_validator_solution
                    ; [REVIEW - architecture] does the proposal validator really need the conditions here?  I would assume it's checking the proposal's puzzle which means that it knows the likely set of conditions it could possibly output.
                    (a delegated_puzzle_reveal delegated_solution)
                  )
                )
              )
            )
          )
          (x)
      )
      ; no proposal_flag so create the oracle announcement
      (c
        ; add announcement attendance required
        ; [REVIEW - optimization] this announcement gets made in either case, so you can move it out of this if block
        (list CREATE_PUZZLE_ANNOUNCEMENT 0)  ; the arguments are secured implicitly in the puzzle of the treasury
        (stager
          ORACLE_SPEND_DELAY
          (recreate_self
            TREASURY_MOD_HASH
            PROPOSAL_VALIDATOR
            PROPOSAL_LENGTH
            PROPOSAL_SOFTCLOSE_LENGTH
            ATTENDANCE_REQUIRED
            PASS_MARGIN
            PROPOSAL_SELF_DESTRUCT_TIME
            ORACLE_SPEND_DELAY
          )
          my_singleton_struct
        )
      )
  )
)
