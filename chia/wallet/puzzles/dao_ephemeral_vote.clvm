(mod (LOCKUP_MOD_HASH EPHEMERAL_VOTE_MODHASH LOCKUP_TIME return_address proposal_id previous_votes my_amount)
  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  (defun calculate_lockup_puzzlehash (LOCKUP_MOD_HASH EPHEMERAL_VOTE_MODHASH LOCKUP_TIME return_address previous_votes)
    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH
                                     (sha256 ONE LOCKUP_TIME)
                                     (sha256tree previous_votes)
                                     (sha256 ONE return_address)
                                     (sha256 ONE EPHEMERAL_VOTE_MODHASH)
                                     (sha256 ONE LOCKUP_MOD_HASH)
    )
  )

  ; main
  (list

    (list CREATE_COIN_ANNOUNCEMENT (sha256tree (list return_address proposal_id previous_votes)))  ; this is for the lockup to assert to prevent it from double voting (it MUST assert this due to its mod rules)
    ; the above also gives this coin's solution some security so MAKE SURE to assert this the first time too

    (list CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (c proposal_id my_amount)))  ; this is for the proposal to assert to count your votes

    (list CREATE_COIN (calculate_lockup_puzzlehash LOCKUP_MOD_HASH EPHEMERAL_VOTE_MODHASH LOCKUP_TIME return_address (c proposal_id previous_votes)))  ; move to lockup coin - this line also adds the new vote to your previous votes

    (list ASSERT_MY_AMOUNT my_amount)  ; make sure you have as much voting power as you say you do
  )
)
