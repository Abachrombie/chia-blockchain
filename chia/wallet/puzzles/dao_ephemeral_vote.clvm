(mod (
  LOCKUP_MOD_HASH
  EPHEMERAL_VOTE_MODHASH
  CAT_MOD_HASH
  CAT_TAIL
  LOCKUP_TIME
  return_address
  proposal_id
  previous_votes
  my_amount  ; this is the weight of your vote
  vote_info  ; this is the information about what to do with your vote  - atm just 1 for yes or 0 for no
)
  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)

  (defun calculate_lockup_puzzlehash (LOCKUP_MOD_HASH EPHEMERAL_VOTE_MODHASH CAT_MOD_HASH CAT_TAIL LOCKUP_TIME return_address previous_votes)
    (puzzle-hash-of-curried-function LOCKUP_MOD_HASH
                                     (sha256 ONE LOCKUP_TIME)
                                     (sha256tree previous_votes)
                                     (sha256 ONE return_address)
                                     (sha256 ONE CAT_TAIL)
                                     (sha256 ONE CAT_MOD_HASH)
                                     (sha256 ONE EPHEMERAL_VOTE_MODHASH)
                                     (sha256 ONE LOCKUP_MOD_HASH)
    )
  )

  ; main
  (list

    (list CREATE_COIN_ANNOUNCEMENT (sha256tree (list return_address proposal_id previous_votes vote_info)))  ; this is for the lockup to assert to prevent it from double voting (it MUST assert this due to its mod rules)
                                                                                                             ; the above also gives this coin's solution some security so MAKE SURE to assert this the first time too
    (list CREATE_PUZZLE_ANNOUNCEMENT (sha256tree (list proposal_id my_amount vote_info)))  ; this is for the proposal to assert to count your votes

    (list CREATE_COIN (calculate_lockup_puzzlehash LOCKUP_MOD_HASH EPHEMERAL_VOTE_MODHASH LOCKUP_TIME return_address (c proposal_id previous_votes)))  ; move to lockup coin - this line also adds the new vote to your previous votes

    (list ASSERT_MY_AMOUNT my_amount)  ; make sure you have as much voting power as you say you do
  )
)
