; [REVIEW - comments] A description of what the purpose of this program is would be nice
; [REVIEW - architecture] I think this puzzle could be more general if the two spend paths are curried into (either literally or by hash)
; [^] a layer above that's p2_1_of_n_puzzles or something like that.  It'll maybe be more optimal in some situations too.
; [^] The main concern is that if new aggregation logic wants to be added/removed, you also need to update the should-be-rock-solid singleton spend path.
(mod (
    SINGLETON_STRUCT
    singleton_inner_puzhash
    delegated_puzzle
    delegated_solution
    my_id
    my_puzhash  ; only needed for merging, set to 0 otherwise
    list_of_parent_amounts  ; only needed for merging
    my_amount  ; only needed for merging
  )

  (include condition_codes.clib)
  (include curry-and-treehash.clib)

  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT singleton_inner_puzhash)
    (puzzle-hash-of-curried-function (f SINGLETON_STRUCT)
      singleton_inner_puzhash
      (sha256tree SINGLETON_STRUCT)
    )
  )

  (defun cons_announcements_to_output(coin_id output)
    (c
      (list CREATE_PUZZLE_ANNOUNCEMENT coin_id)
      (c
        ; [REVIEW - optimization] why do we care to assert if we're the one creating the outputs?
        ; [^] We're only ever going to create more than our current amount, who cares where the money comes from?
        ; [REVIEW - bugs] I don't think this assertion could possibly work because there's no origin information sha'd in
        ; [REVIEW - bugs] A malicious party could have multiple primary outputs all think they are getting the sole announcement from supply coins when in fact one set of supply coins satisfies all of the primaries' assertions.
        (list ASSERT_COIN_ANNOUNCEMENT (sha256tree (list coin_id 0)))
        output
      )
    )
  )

  (defun for_parent_amounts (my_puzhash list_of_parent_amounts total)
    (if list_of_parent_amounts
        (cons_announcements_to_output
          ; [REVIEW - optimization] why do we care if they have the same puzzle hash as us.
          ; [^] _They_ should only care that _we_ are the same puzhash as them (so they don't get spent by some rando).
          ; [^] This as it sits blocks potentially folding things that could be meltable in.
          ; [^] The alternative would be to pass in a list of coin_id/amount pairs and have the asserting p2_singletons assert that their amount is accurate.
          (calculate_coin_id (f (f list_of_parent_amounts)) my_puzhash (f (r (f list_of_parent_amounts))))  ; asserts that all the coins have the same puzzle as me
          (for_parent_amounts my_puzhash (r list_of_parent_amounts) (+ total (f (r (f list_of_parent_amounts)))))
        )
        (list
          ; [REVIEW - comments] I think higher would be fine, there's probably no burning need for aggregation on the part of an honest party
          (list ASSERT_HEIGHT_RELATIVE 5)  ; TODO: should this be higher or lower?
          (list CREATE_COIN my_puzhash total)
        )
    )
  )

  (defun-inline give_self_to_merge (my_puzhash my_id)
    (list
      (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 my_puzhash my_id))
      (list CREATE_COIN_ANNOUNCEMENT 0)
    )
  )

  (if my_puzhash
      ; we are merging coins to make a larger coin
      (c
        (list ASSERT_MY_PUZZLEHASH my_puzhash)
        (if list_of_parent_amounts
            ; we are making the output
            (c
              (list ASSERT_MY_AMOUNT my_amount)
              (for_parent_amounts my_puzhash list_of_parent_amounts my_amount)
            )
            ; we are letting another coin make the output
            (give_self_to_merge my_puzhash my_id)
        )
      )
      ; we are being spent by our singleton
      (c
        (list
          ASSERT_PUZZLE_ANNOUNCEMENT
          (sha256
            (calculate_full_puzzle_hash SINGLETON_STRUCT singleton_inner_puzhash)
            (sha256tree (list my_id (sha256tree delegated_puzzle)))
          )
        )
        (c
          (list CREATE_COIN_ANNOUNCEMENT '$')
          (c
            (list ASSERT_MY_COIN_ID my_id)
            (a delegated_puzzle delegated_solution)
          )
        )
      )
  )

)
