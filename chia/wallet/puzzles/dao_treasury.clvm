; This represents the controls over the money that the treasury owns.
; Money can be sent to this via p2_singleton or by spending this coin through the "add money" spend case

(mod (
  (
    ; COMMENT: When using the modern compiler, you can destructure this like so (@ SINGLETON_STRUCT (SINGLETON_MOD_HASH SINGLETON_ID . LAUNCHER_PUZZLE_HASH))
    SINGLETON_STRUCT  ; ((SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH)))
    TREASURY_MOD_HASH
    PROPOSAL_MOD_HASH
    PROPOSAL_TIMER_MOD_HASH
    LOCKUP_MOD_HASH
    CAT_MOD_HASH
    CAT_TAIL_HASH
    CURRENT_CAT_ISSUANCE
    ATTENDANCE_REQUIRED_PERCENTAGE  ; percent of total potential votes needed to have a chance at passing
    PASS_MARGIN  ; what percentage of votes should be yes (vs no) for a proposal to pass. Represented as 0 - 10000 (default 5100)
    PROPOSAL_TIMELOCK ; relative timelock -- how long proposals should live during this treasury's lifetime
  )
  my_amount         ; current amount
  new_amount_change ; may be negative or positive. Is zero during eve spend
  my_inner_puzhash_or_proposal_id ; either the current treasury puzzlehash OR proposal ID
  announcement_messages_list_or_payment_nonce  ; this is a list of messages which the treasury will parrot - assert from the proposal and also create
  new_puzhash  ; if this variable is 0 then we do the "add_money" spend case and all variables below are not needed
  proposal_innerpuz_or_optional_p2_singleton_coin_id
  proposal_current_votes ; tally of yes votes
  proposal_total_votes   ; total votes cast (by number of cat-mojos)
  type  ; this is used for the recreating self type
  extra_value  ; this is used for recreating self
)
  (include condition_codes.clvm)
  (include curry-and-treehash.clinc)
  (include curry_by_index.clib)
  (include *standard-cl-21*)

  (defun-inline mod_hash_for_singleton_struct (SINGLETON_STRUCT) (f SINGLETON_STRUCT))
  (defun-inline launcher_id_for_singleton_struct (SINGLETON_STRUCT) (f (r SINGLETON_STRUCT)))

  ; take two lists and merge them into one
  (defun merge_list (list_a list_b)
    (if list_a
      (c (f list_a) (merge_list (r list_a) list_b))
      list_b
    )
  )

  (defun-inline calculate_full_puzzle_hash (SINGLETON_STRUCT inner_puzzle_hash)
     (puzzle-hash-of-curried-function (mod_hash_for_singleton_struct SINGLETON_STRUCT)
                                      inner_puzzle_hash
                                      (sha256tree SINGLETON_STRUCT)
     )
  )

  (defun-inline calculate_proposal_puzzle (
    PROPOSAL_SINGLETON_STRUCT
    PROPOSAL_MOD_HASH
    PROPOSAL_TIMER_MOD_HASH
    CAT_MOD_HASH
    TREASURY_MOD_HASH
    LOCKUP_MOD_HASH
    CAT_TAIL_HASH
    TREASURY_ID
    proposal_current_votes
    proposal_total_votes
    proposal_innerpuz
    )
    (puzzle-hash-of-curried-function PROPOSAL_MOD_HASH
                                     (sha256tree proposal_innerpuz)
                                     (sha256 ONE proposal_total_votes)
                                     (sha256 ONE proposal_current_votes)
                                     (sha256 ONE TREASURY_ID)
                                     (sha256 ONE CAT_TAIL_HASH)
                        				     (sha256 ONE LOCKUP_MOD_HASH)
                        				     (sha256 ONE TREASURY_MOD_HASH)
                                     (sha256 ONE CAT_MOD_HASH)
                                     (sha256 ONE PROPOSAL_TIMER_MOD_HASH)
                                     (sha256 ONE PROPOSAL_MOD_HASH)
                                     (sha256tree PROPOSAL_SINGLETON_STRUCT)
    )
  )

  ; this allows a proposal to make the treasury make an announcement
  (defun loop_through_announcements (proposal_puzhash announcement_messages_list)
    (if announcement_messages_list
      (c
        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 proposal_puzhash (f announcement_messages_list)))
        (c
          (list CREATE_PUZZLE_ANNOUNCEMENT (f announcement_messages_list))
          (loop_through_announcements proposal_puzhash (r announcement_messages_list))
        )
      )
      ()
    )
  )

  (defun create_puzzle_asserts (
    PROPOSAL_TIMELOCK
    proposal_puzhash
    my_singleton_id
    new_puzhash
    new_amount_change
    announcement_messages_list
    type
  )
    ; COMMENT: The two ASSERT_PUZZLE_ANNOUNCEMENTs here should probably just be combined into one yeah?
    (c
      (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 proposal_puzhash (sha256tree (list my_singleton_id PROPOSAL_TIMELOCK))))  ; the proposal format will make this
      (c
        ; the proposals innerpuz will make this - this secures these values - we needn't secure extra_value as we check it ourselves
        (list ASSERT_PUZZLE_ANNOUNCEMENT (sha256 proposal_puzhash (sha256tree (list type new_puzhash new_amount_change))))
        (loop_through_announcements proposal_puzhash announcement_messages_list)
      )
    )
  )

  (defun-inline recurry_self (TREASURY_MOD_HASH index_value_pairs_list CURRENT_PARAMS)
    (puzzle-hash-of-curried-function
      ; COMMENT: We could change the treasury mod hash, but it would take two spends right? I think this should check index_value_pairs_list for a TREASURY_MOD change and use it if it exists.
      TREASURY_MOD_HASH
      (sha256tree
        (recurry_by_index_ordered
          index_value_pairs_list   ; MUST BE ORDERED
          0  ; must be 0 on initial call
          CURRENT_PARAMS  ; current list of curry params
        )
      )
    )
  )


  (defun-inline recreate_self_condition (
    TREASURY_MOD_HASH
    CURRENT_PARAMS
    type
    new_puzhash
    extra_value
    new_amount_change
    my_amount
    my_singleton_id
  )
    ; COMMENT: this whole if tree can be on just the CREATE_COIN's puzhash since the amount and hint are the same in every case
    (if (= type 'u')  ; unchanged
      (list
        (list CREATE_COIN new_puzhash (+ my_amount new_amount_change) (c my_singleton_id 0))
        ; COMMENT: this ends up double wrapping the singleton right? You need to recreate with the current inner puzzle not full puzzle.
        (list ASSERT_MY_PUZZLEHASH new_puzhash)
      )
      (if (= type 'r')  ; recurry by index
        (list (list CREATE_COIN (recurry_self TREASURY_MOD_HASH new_puzhash CURRENT_PARAMS ()) (+ my_amount new_amount_change) (c my_singleton_id 0)))
        (if (= type 'n')  ; new puzhash
          (if (= new_puzhash (sha256tree extra_value))  ; check that the solution contains a reveal of the new puzhash
            (list (list CREATE_COIN new_puzhash (+ my_amount new_amount_change) (c my_singleton_id 0)))
            (x)
          )
          (x)
        )
      )
    )
  )

  ; main
  (c
    (list ASSERT_MY_AMOUNT my_amount)
    (if new_puzhash
      ; this is the payout spend case
      (c
        (list CREATE_PUZZLE_ANNOUNCEMENT my_inner_puzhash_or_proposal_id)  ; announce the proposal we're approving, and the current amount of CATs in the world
        (merge_list  ; this will be very short in practice
          (recreate_self_condition
            TREASURY_MOD_HASH
            (list
              SINGLETON_STRUCT  ; ((SINGLETON_MOD_HASH, (SINGLETON_ID, LAUNCHER_PUZZLE_HASH)))
              TREASURY_MOD_HASH
              PROPOSAL_MOD_HASH
              PROPOSAL_TIMER_MOD_HASH
              LOCKUP_MOD_HASH
              CAT_MOD_HASH
              CAT_TAIL_HASH
              CURRENT_CAT_ISSUANCE
              ATTENDANCE_REQUIRED_PERCENTAGE  ; percent of total potential votes needed to have a chance at passing
              PASS_MARGIN  ; what percentage of votes should be yes (vs no) for a proposal to pass. Represented as 0 - 10000 (default 5100)
              PROPOSAL_TIMELOCK
            )
            type
            new_puzhash
            extra_value
            new_amount_change
            my_amount
            (f (r SINGLETON_STRUCT))
          )
          (create_puzzle_asserts
            PROPOSAL_TIMELOCK
            (calculate_full_puzzle_hash (c (f SINGLETON_STRUCT) (c my_inner_puzhash_or_proposal_id (r (r SINGLETON_STRUCT))))  ; singleton struct with their singleton ID
                (calculate_proposal_puzzle
                  (c (f SINGLETON_STRUCT) (c my_inner_puzhash_or_proposal_id (r (r SINGLETON_STRUCT))))
                  PROPOSAL_MOD_HASH
                  PROPOSAL_TIMER_MOD_HASH
                  CAT_MOD_HASH
                  TREASURY_MOD_HASH
                  LOCKUP_MOD_HASH
                  CAT_TAIL_HASH
                  (f (r SINGLETON_STRUCT))
                  proposal_current_votes
                  proposal_total_votes
                  proposal_innerpuz_or_optional_p2_singleton_coin_id
                )
            )
            (launcher_id_for_singleton_struct SINGLETON_STRUCT)
            new_puzhash
            new_amount_change
            announcement_messages_list_or_payment_nonce
            type
          )
        )
      )
      ; this is the add money spend case
      ; COMMENT: This should probably be 0 or something configurable to prevent spaming the add money case a DOS
      (if (> new_amount_change -1)
        (merge_list
          ; COMMENT: maybe this should be a loop so you can do more than one p2_singleton at once
          (if proposal_innerpuz_or_optional_p2_singleton_coin_id
            ; COMMENT: An attacker here could give you a p2_singleton to this DAO, then specify an amount increase of 0 or 1 and melt the p2_singleton's value without actually giving it to the DAO
            (list
              (list CREATE_PUZZLE_ANNOUNCEMENT proposal_innerpuz_or_optional_p2_singleton_coin_id)
              ; COMMENT: Using the existing p2_singleton here pretty much eliminates support for CATs or NFTs being sent to the DAO
              (list ASSERT_COIN_ANNOUNCEMENT (sha256 proposal_innerpuz_or_optional_p2_singleton_coin_id '$'))
            )
            (list
              ; COMMENT: should this be a coin announcement? Is it possible that you might not want to do this spend if someone else increases the amount before you?
              (list
                CREATE_PUZZLE_ANNOUNCEMENT  ; by creating this announcement the payer can assert and make sure its their payment that's being taken
                (sha256tree (list new_amount_change announcement_messages_list_or_payment_nonce))
              )
            )
          )
          (list
            (list CREATE_COIN my_inner_puzhash_or_proposal_id (+ new_amount_change my_amount) (c (f (r SINGLETON_STRUCT)) 0))
            (list ASSERT_MY_PUZZLEHASH (calculate_full_puzzle_hash SINGLETON_STRUCT my_inner_puzhash_or_proposal_id))

          )
          (list CREATE_PUZZLE_ANNOUNCEMENT proposal_innerpuz_or_optional_p2_singleton_coin_id)
        )
        (x)
      )
    )
  )
)
